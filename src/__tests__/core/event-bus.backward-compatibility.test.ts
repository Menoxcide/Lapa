/**
 * Backward Compatibility Tests for LAPA Core Event Bus
 * 
 * These tests verify that the event bus system maintains compatibility with
 * existing LAPA v1.1 components and follows local-first principles.
 */

import { LAPAEventBus } from '../../core/event-bus.ts';
import { 
  TaskCreatedEvent, 
  HandoffInitiatedEvent,
  AgentRegisteredEvent
} from '../../core/types/event-types.ts';
import { setupDefaultLAPARoutes } from '../../core/utils/event-router.ts';

// Mock the existing handoff system for compatibility testing
jest.mock('../../orchestrator/handoffs.js', () => {
  return {
    HybridHandoffSystem: jest.fn().mockImplementation(() => {
      return {
        executeTaskWithHandoffs: jest.fn().mockResolvedValue({ result: 'success' })
      };
    })
  };
});

// Mock the existing swarm delegate for compatibility testing
jest.mock('../../swarm/delegate.js', () => {
  return {
    SwarmDelegate: jest.fn().mockImplementation(() => {
      return {
        delegateTask: jest.fn().mockResolvedValue({ success: true })
      };
    })
  };
});

describe('LAPA Core Event Bus Backward Compatibility', () => {
  let testEventBus: LAPAEventBus;

  beforeEach(() => {
    testEventBus = new LAPAEventBus({
      enableLocalFirst: true,
      maxConcurrentEvents: 1000,
      eventTTL: 60000
    });
    setupDefaultLAPARoutes();
  });

  afterEach(() => {
    testEventBus.clear();
    jest.clearAllMocks();
  });

  it('should integrate with existing handoff mechanisms', async () => {
    // Import the mocked handoff system
    const { HybridHandoffSystem } = await import('../../orchestrator/handoffs');
    const handoffSystem = new HybridHandoffSystem();

    // Create a handoff event that would be generated by the existing system
    const handoffEvent: HandoffInitiatedEvent = {
      id: 'compat-handoff-1',
      type: 'handoff.initiated',
      timestamp: Date.now(),
      source: 'existing-agent',
      payload: {
        sourceAgentId: 'source-agent-1',
        targetAgentId: 'target-agent-1',
        taskId: 'compat-task-1',
        context: { legacy: true, data: 'test' },
        priority: 'medium'
      }
    };

    // Set up event listener to verify integration
    let receivedEvent: HandoffInitiatedEvent | null = null;
    testEventBus.subscribe('handoff.initiated', (event) => {
      receivedEvent = event;
    });

    // Publish the event (simulating existing system generating event)
    await testEventBus.publish(handoffEvent);

    // Allow time for processing
    await new Promise(resolve => setTimeout(resolve, 10));

    // Verify the event was received
    expect(receivedEvent).toEqual(handoffEvent);

    // Verify the handoff system can still be used directly
    const task = { id: 'test-task', description: 'Test', type: 'test', priority: 1, context: {} };
    const result = await handoffSystem.executeTaskWithHandoffs(task, {});
    expect(result.result).toBe('success');
  });

  it('should integrate with existing swarm delegation', async () => {
    // Import the mocked swarm delegate
    const { SwarmDelegate } = await import('../../swarm/delegate');
    const swarmDelegate = new SwarmDelegate();

    // Create an agent registration event that would be generated by the existing system
    const agentEvent: AgentRegisteredEvent = {
      id: 'compat-agent-1',
      type: 'agent.registered',
      timestamp: Date.now(),
      source: 'swarm-manager',
      payload: {
        agentId: 'existing-agent-1',
        name: 'Legacy Agent',
        capabilities: ['text-generation', 'qa'],
        isLocal: true,
        type: 'legacy'
      }
    };

    // Set up event listener to verify integration
    let receivedEvent: AgentRegisteredEvent | null = null;
    testEventBus.subscribe('agent.registered', (event) => {
      receivedEvent = event;
    });

    // Publish the event (simulating existing system generating event)
    await testEventBus.publish(agentEvent);

    // Allow time for processing
    await new Promise(resolve => setTimeout(resolve, 10));

    // Verify the event was received
    expect(receivedEvent).toEqual(agentEvent);

    // Verify the swarm delegate can still be used directly
    const task = { id: 'delegate-task', description: 'Test', type: 'test', priority: 1, context: {} };
    const result = await swarmDelegate.delegateTask(task, {});
    expect(result.success).toBe(true);
  });

  it('should maintain local-first compliance', async () => {
    // Verify the event bus is configured for local-first operation
    const config = testEventBus.getConfig();
    expect(config.enableLocalFirst).toBe(true);

    // Create a task event that should be handled locally
    const taskEvent: TaskCreatedEvent = {
      id: 'local-task-1',
      type: 'task.created',
      timestamp: Date.now(),
      source: 'local-agent',
      payload: {
        taskId: 'local-task-1',
        description: 'Local task',
        type: 'local-test',
        priority: 1,
        context: { local: true }
      }
    };

    // Set up event listener to verify local handling
    let receivedEvent: TaskCreatedEvent | null = null;
    testEventBus.subscribe('task.created', (event) => {
      receivedEvent = event;
    });

    // Record start time
    const startTime = performance.now();

    // Publish the event
    await testEventBus.publish(taskEvent);

    // Allow time for processing
    await new Promise(resolve => setTimeout(resolve, 5));

    // Record end time
    const endTime = performance.now();
    const duration = endTime - startTime;

    // Verify the event was received
    expect(receivedEvent).toEqual(taskEvent);

    // Verify local performance (should be very fast)
    expect(duration).toBeLessThan(5);
  });

  it('should support existing event patterns from v1.1', async () => {
    // Create events using patterns that existed in v1.1
    const legacyEvents = [
      {
        id: 'legacy-1',
        type: 'task.created',
        timestamp: Date.now(),
        source: 'legacy-system',
        payload: {
          taskId: 'legacy-task-1',
          description: 'Legacy task',
          type: 'legacy',
          priority: 1,
          context: {}
        }
      },
      {
        id: 'legacy-2',
        type: 'task.completed',
        timestamp: Date.now(),
        source: 'legacy-system',
        payload: {
          taskId: 'legacy-task-1',
          result: 'success',
          duration: 100
        }
      }
    ];

    // Counters for received events
    let taskCreatedCount = 0;
    let taskCompletedCount = 0;

    // Set up listeners for legacy event types
    testEventBus.subscribe('task.created', () => {
      taskCreatedCount++;
    });

    testEventBus.subscribe('task.completed', () => {
      taskCompletedCount++;
    });

    // Publish legacy events
    for (const event of legacyEvents) {
      await testEventBus.publish(event);
    }

    // Allow time for processing
    await new Promise(resolve => setTimeout(resolve, 10));

    // Verify all legacy events were received
    expect(taskCreatedCount).toBe(1);
    expect(taskCompletedCount).toBe(1);
  });

  it('should handle configuration migration from v1.1', () => {
    // Get default configuration
    const defaultConfig = testEventBus.getConfig();
    
    // Verify default configuration matches local-first principles
    expect(defaultConfig.enableLocalFirst).toBe(true);
    expect(defaultConfig.maxConcurrentEvents).toBeGreaterThanOrEqual(100);
    expect(defaultConfig.eventTTL).toBeGreaterThan(0);
    
    // Update configuration (simulating migration from v1.1)
    testEventBus.updateConfig({
      maxConcurrentEvents: 2000,
      eventTTL: 120000 // 2 minutes
    });
    
    // Verify updated configuration
    const updatedConfig = testEventBus.getConfig();
    expect(updatedConfig.maxConcurrentEvents).toBe(2000);
    expect(updatedConfig.eventTTL).toBe(120000);
    // Other values should remain unchanged
    expect(updatedConfig.enableLocalFirst).toBe(true);
  });
});